#!/usr/bin/env bash
# commands/app.cmd - Application management command
[[ ! ${FORTRESS_DIR} ]] && >&2 echo -e "\033[31mThis script is not intended to be run directly!\033[0m" && exit 1

# Parse subcommand
SUBCOMMAND="${FORTRESS_PARAMS[0]:-list}"
shift FORTRESS_PARAMS

case "${SUBCOMMAND}" in
  deploy)
    deployApp "$@"
    ;;
  list)
    listApps
    ;;
  status)
    appStatus "${FORTRESS_PARAMS[0]}" "$@"
    ;;
  update)
    updateApp "${FORTRESS_PARAMS[0]}" "$@"
    ;;
  remove)
    removeApp "${FORTRESS_PARAMS[0]}" "$@"
    ;;
  restart)
    restartApp "${FORTRESS_PARAMS[0]}" "$@"
    ;;
  stop)
    stopApp "${FORTRESS_PARAMS[0]}" "$@"
    ;;
  start)
    startApp "${FORTRESS_PARAMS[0]}" "$@"
    ;;
  scale)
    scaleApp "${FORTRESS_PARAMS[0]}" "$@"
    ;;
  limits)
    setAppLimits "${FORTRESS_PARAMS[0]}" "$@"
    ;;
  *)
    fatal "Unknown app subcommand: ${SUBCOMMAND}"
    ;;
esac

function deployApp() {
  local APP_NAME=""
  local DOMAIN=""
  local PORT=""
  local IMAGE=""
  local ENV_FILE=""
  local APP_TYPE="web"
  local REPLICAS=1
  
  # Parse arguments
  while [[ $# -gt 0 ]]; do
    case $1 in
      --domain=*)
        DOMAIN="${1#*=}"
        shift
        ;;
      --port=*)
        PORT="${1#*=}"
        shift
        ;;
      --image=*)
        IMAGE="${1#*=}"
        shift
        ;;
      --env-file=*)
        ENV_FILE="${1#*=}"
        shift
        ;;
      --type=*)
        APP_TYPE="${1#*=}"
        shift
        ;;
      --replicas=*)
        REPLICAS="${1#*=}"
        shift
        ;;
      *)
        if [[ -z "${APP_NAME}" ]]; then
          APP_NAME="$1"
        fi
        shift
        ;;
    esac
  done
  
  # Validate inputs
  [[ -z "${APP_NAME}" ]] && fatal "App name is required"
  [[ -z "${DOMAIN}" ]] && fatal "Domain is required (--domain=example.com)"
  [[ -z "${PORT}" ]] && fatal "Port is required (--port=3000)"
  [[ -z "${IMAGE}" ]] && IMAGE="${APP_NAME}:latest"
  
  # Validate app name
  if [[ ! "${APP_NAME}" =~ ^[a-z0-9-]+$ ]]; then
    fatal "App name must contain only lowercase letters, numbers, and hyphens"
  fi
  
  info "Deploying app: ${APP_NAME}"
  info "  Domain: ${DOMAIN}"
  info "  Port: ${PORT}"
  info "  Image: ${IMAGE}"
  
  # Create app directory
  local APP_DIR="${FORTRESS_APPS_DIR}/${APP_NAME}"
  if [[ -d "${APP_DIR}" ]]; then
    warning "App directory already exists. Updating configuration..."
  else
    mkdir -p "${APP_DIR}/data"
  fi
  
  # Generate environment file
  if [[ -z "${ENV_FILE}" ]]; then
    cat > "${APP_DIR}/.env" <<EOF
# Auto-generated by Fortress
APP_NAME=${APP_NAME}
APP_DOMAIN=${DOMAIN}
APP_PORT=${PORT}
APP_IMAGE=${IMAGE}
APP_REPLICAS=${REPLICAS}

# Database connection (if needed)
DATABASE_URL=postgresql://\${DB_USER}:\${DB_PASS}@postgres:5432/\${DB_NAME}

# Redis connection (if needed)
REDIS_URL=redis://redis:6379

# Add your environment variables below
NODE_ENV=production
EOF
  else
    cp "${ENV_FILE}" "${APP_DIR}/.env"
  fi
  
  # Generate docker-compose.yml
  cat > "${APP_DIR}/docker-compose.yml" <<EOF
version: '3.8'

services:
  app:
    image: ${IMAGE}
    container_name: fortress_${APP_NAME}
    restart: unless-stopped
    networks:
      - fortress
    env_file:
      - .env
    labels:
      # Traefik configuration
      - "traefik.enable=true"
      - "traefik.docker.network=fortress"
      
      # HTTP router
      - "traefik.http.routers.${APP_NAME}.rule=Host(\`${DOMAIN}\`)"
      - "traefik.http.routers.${APP_NAME}.entrypoints=web"
      - "traefik.http.routers.${APP_NAME}.middlewares=${APP_NAME}-redirect"
      
      # HTTPS router
      - "traefik.http.routers.${APP_NAME}-secure.rule=Host(\`${DOMAIN}\`)"
      - "traefik.http.routers.${APP_NAME}-secure.entrypoints=websecure"
      - "traefik.http.routers.${APP_NAME}-secure.tls=true"
      - "traefik.http.routers.${APP_NAME}-secure.tls.certresolver=letsencrypt"
      - "traefik.http.routers.${APP_NAME}-secure.middlewares=security-headers@file,rate-limit@file"
      
      # Service
      - "traefik.http.services.${APP_NAME}.loadbalancer.server.port=${PORT}"
      
      # Redirect HTTP to HTTPS
      - "traefik.http.middlewares.${APP_NAME}-redirect.redirectscheme.scheme=https"
      - "traefik.http.middlewares.${APP_NAME}-redirect.redirectscheme.permanent=true"
      
      # Fortress labels
      - "fortress.app=${APP_NAME}"
      - "fortress.type=${APP_TYPE}"
      - "fortress.managed=true"
      - "fortress.domain=${DOMAIN}"
      - "fortress.port=${PORT}"
    deploy:
      replicas: ${REPLICAS}
      resources:
        limits:
          cpus: '0.5'
          memory: 512M
        reservations:
          cpus: '0.1'
          memory: 128M
    healthcheck:
      test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost:${PORT}/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s
    volumes:
      - ./data:/app/data
      - /etc/localtime:/etc/localtime:ro
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"
        labels: "fortress.app=${APP_NAME}"

networks:
  fortress:
    external: true
EOF
  
  # Create app configuration
  cat > "${APP_DIR}/fortress.yml" <<EOF
name: ${APP_NAME}
type: ${APP_TYPE}
domain: ${DOMAIN}
port: ${PORT}
image: ${IMAGE}
created: $(date -u +"%Y-%m-%dT%H:%M:%SZ")
status: deploying
EOF
  
  # Start the application
  info "Starting application..."
  cd "${APP_DIR}"
  ${DOCKER_COMPOSE_COMMAND} up -d
  
  # Wait for health check
  info "Waiting for application to be healthy..."
  local RETRIES=30
  while [[ ${RETRIES} -gt 0 ]]; do
    if docker exec "fortress_${APP_NAME}" wget --no-verbose --tries=1 --spider "http://localhost:${PORT}/health" 2>/dev/null; then
      success "Application is healthy!"
      break
    fi
    RETRIES=$((RETRIES - 1))
    if [[ ${RETRIES} -eq 0 ]]; then
      warning "Health check failed, but application may still be running"
    else
      sleep 2
    fi
  done
  
  # Update app status
  sed -i 's/status: deploying/status: running/' "${APP_DIR}/fortress.yml"
  
  success "Application deployed successfully!"
  echo ""
  echo "  URL: https://${DOMAIN}"
  echo "  Container: fortress_${APP_NAME}"
  echo "  Logs: fortress logs ${APP_NAME}"
  echo "  Status: fortress app status ${APP_NAME}"
}

function listApps() {
  info "Listing all applications..."
  echo ""
  
  printf "%-20s %-30s %-10s %-15s %-10s\n" "NAME" "DOMAIN" "PORT" "STATUS" "REPLICAS"
  printf "%-20s %-30s %-10s %-15s %-10s\n" "----" "------" "----" "------" "--------"
  
  for APP_DIR in "${FORTRESS_APPS_DIR}"/*; do
    if [[ -d "${APP_DIR}" ]] && [[ -f "${APP_DIR}/fortress.yml" ]]; then
      local APP_NAME=$(basename "${APP_DIR}")
      local CONFIG=$(cat "${APP_DIR}/fortress.yml")
      local DOMAIN=$(echo "${CONFIG}" | grep "^domain:" | cut -d' ' -f2)
      local PORT=$(echo "${CONFIG}" | grep "^port:" | cut -d' ' -f2)
      
      # Get container status
      local STATUS="stopped"
      if docker ps --format "{{.Names}}" | grep -q "fortress_${APP_NAME}"; then
        STATUS="running"
      fi
      
      # Get replica count
      local REPLICAS=$(docker ps --filter "label=fortress.app=${APP_NAME}" --format "{{.Names}}" | wc -l)
      
      printf "%-20s %-30s %-10s %-15s %-10s\n" "${APP_NAME}" "${DOMAIN}" "${PORT}" "${STATUS}" "${REPLICAS}"
    fi
  done
}

function appStatus() {
  local APP_NAME="$1"
  [[ -z "${APP_NAME}" ]] && fatal "App name is required"
  
  local APP_DIR="${FORTRESS_APPS_DIR}/${APP_NAME}"
  [[ ! -d "${APP_DIR}" ]] && fatal "App '${APP_NAME}' not found"
  
  info "Status for app: ${APP_NAME}"
  echo ""
  
  # Load configuration
  local CONFIG=$(cat "${APP_DIR}/fortress.yml")
  local DOMAIN=$(echo "${CONFIG}" | grep "^domain:" | cut -d' ' -f2)
  local PORT=$(echo "${CONFIG}" | grep "^port:" | cut -d' ' -f2)
  local IMAGE=$(echo "${CONFIG}" | grep "^image:" | cut -d' ' -f2)
  
  echo "Configuration:"
  echo "  Domain: ${DOMAIN}"
  echo "  Port: ${PORT}"
  echo "  Image: ${IMAGE}"
  echo ""
  
  # Container status
  echo "Container Status:"
  if docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}" | grep "fortress_${APP_NAME}"; then
    echo ""
    
    # Resource usage
    echo "Resource Usage:"
    docker stats --no-stream --format "table {{.Container}}\t{{.CPUPerc}}\t{{.MemUsage}}" "fortress_${APP_NAME}"
    
    # Health check
    echo ""
    echo "Health Check:"
    if docker exec "fortress_${APP_NAME}" wget --no-verbose --tries=1 --spider "http://localhost:${PORT}/health" 2>/dev/null; then
      success "Healthy"
    else
      error "Unhealthy"
    fi
  else
    error "Container is not running"
  fi
}

function updateApp() {
  local APP_NAME="$1"
  [[ -z "${APP_NAME}" ]] && fatal "App name is required"
  shift
  
  local APP_DIR="${FORTRESS_APPS_DIR}/${APP_NAME}"
  [[ ! -d "${APP_DIR}" ]] && fatal "App '${APP_NAME}' not found"
  
  local NEW_IMAGE=""
  local STRATEGY="rolling"
  
  # Parse arguments
  while [[ $# -gt 0 ]]; do
    case $1 in
      --image=*)
        NEW_IMAGE="${1#*=}"
        shift
        ;;
      --strategy=*)
        STRATEGY="${1#*=}"
        shift
        ;;
      *)
        shift
        ;;
    esac
  done
  
  [[ -z "${NEW_IMAGE}" ]] && fatal "New image is required (--image=myapp:v2)"
  
  info "Updating app: ${APP_NAME}"
  info "  New image: ${NEW_IMAGE}"
  info "  Strategy: ${STRATEGY}"
  
  cd "${APP_DIR}"
  
  case "${STRATEGY}" in
    rolling)
      # Zero-downtime rolling update
      info "Performing rolling update..."
      
      # Update the image in docker-compose.yml
      sed -i "s|image: .*|image: ${NEW_IMAGE}|" docker-compose.yml
      
      # Scale up with new version
      ${DOCKER_COMPOSE_COMMAND} up -d --scale app=2 --no-recreate
      
      # Wait for new container to be healthy
      sleep 10
      
      # Remove old container
      local OLD_CONTAINER=$(docker ps --filter "label=fortress.app=${APP_NAME}" --format "{{.Names}}" | head -n1)
      docker stop "${OLD_CONTAINER}"
      docker rm "${OLD_CONTAINER}"
      
      success "Rolling update completed!"
      ;;
      
    recreate)
      # Simple recreate strategy
      info "Recreating container..."
      ${DOCKER_COMPOSE_COMMAND} up -d --force-recreate
      success "Container recreated!"
      ;;
      
    *)
      fatal "Unknown strategy: ${STRATEGY}"
      ;;
  esac
  
  # Update configuration
  sed -i "s|image: .*|image: ${NEW_IMAGE}|" fortress.yml
  echo "updated: $(date -u +"%Y-%m-%dT%H:%M:%SZ")" >> fortress.yml
}

function removeApp() {
  local APP_NAME="$1"
  [[ -z "${APP_NAME}" ]] && fatal "App name is required"
  
  local APP_DIR="${FORTRESS_APPS_DIR}/${APP_NAME}"
  [[ ! -d "${APP_DIR}" ]] && fatal "App '${APP_NAME}' not found"
  
  # Confirm removal
  warning "This will remove the app '${APP_NAME}' and all its data!"
  read -p "Are you sure? (y/N) " -n 1 -r
  echo
  if [[ ! $REPLY =~ ^[Yy]$ ]]; then
    info "Removal cancelled"
    return
  fi
  
  info "Removing app: ${APP_NAME}"
  
  # Stop and remove containers
  cd "${APP_DIR}"
  ${DOCKER_COMPOSE_COMMAND} down -v
  
  # Backup before removal
  local BACKUP_FILE="${FORTRESS_BACKUPS_DIR}/removed/${APP_NAME}-$(date +%Y%m%d-%H%M%S).tar.gz"
  mkdir -p "${FORTRESS_BACKUPS_DIR}/removed"
  tar -czf "${BACKUP_FILE}" -C "${FORTRESS_APPS_DIR}" "${APP_NAME}"
  info "Backup saved to: ${BACKUP_FILE}"
  
  # Remove app directory
  rm -rf "${APP_DIR}"
  
  success "App removed successfully!"
}

function restartApp() {
  local APP_NAME="$1"
  [[ -z "${APP_NAME}" ]] && fatal "App name is required"
  
  local APP_DIR="${FORTRESS_APPS_DIR}/${APP_NAME}"
  [[ ! -d "${APP_DIR}" ]] && fatal "App '${APP_NAME}' not found"
  
  info "Restarting app: ${APP_NAME}"
  
  cd "${APP_DIR}"
  ${DOCKER_COMPOSE_COMMAND} restart
  
  success "App restarted successfully!"
}

function stopApp() {
  local APP_NAME="$1"
  [[ -z "${APP_NAME}" ]] && fatal "App name is required"
  
  local APP_DIR="${FORTRESS_APPS_DIR}/${APP_NAME}"
  [[ ! -d "${APP_DIR}" ]] && fatal "App '${APP_NAME}' not found"
  
  info "Stopping app: ${APP_NAME}"
  
  cd "${APP_DIR}"
  ${DOCKER_COMPOSE_COMMAND} stop
  
  success "App stopped successfully!"
}

function startApp() {
  local APP_NAME="$1"
  [[ -z "${APP_NAME}" ]] && fatal "App name is required"
  
  local APP_DIR="${FORTRESS_APPS_DIR}/${APP_NAME}"
  [[ ! -d "${APP_DIR}" ]] && fatal "App '${APP_NAME}' not found"
  
  info "Starting app: ${APP_NAME}"
  
  cd "${APP_DIR}"
  ${DOCKER_COMPOSE_COMMAND} start
  
  success "App started successfully!"
}

function scaleApp() {
  local APP_NAME="$1"
  [[ -z "${APP_NAME}" ]] && fatal "App name is required"
  shift
  
  local REPLICAS="$1"
  [[ -z "${REPLICAS}" ]] && fatal "Number of replicas is required"
  
  local APP_DIR="${FORTRESS_APPS_DIR}/${APP_NAME}"
  [[ ! -d "${APP_DIR}" ]] && fatal "App '${APP_NAME}' not found"
  
  info "Scaling app '${APP_NAME}' to ${REPLICAS} replicas"
  
  cd "${APP_DIR}"
  ${DOCKER_COMPOSE_COMMAND} up -d --scale app="${REPLICAS}"
  
  # Update configuration
  sed -i "s/APP_REPLICAS=.*/APP_REPLICAS=${REPLICAS}/" .env
  
  success "App scaled to ${REPLICAS} replicas!"
}

function setAppLimits() {
  local APP_NAME="$1"
  [[ -z "${APP_NAME}" ]] && fatal "App name is required"
  shift
  
  local CPU_LIMIT=""
  local MEMORY_LIMIT=""
  
  # Parse arguments
  while [[ $# -gt 0 ]]; do
    case $1 in
      --cpu=*)
        CPU_LIMIT="${1#*=}"
        shift
        ;;
      --memory=*)
        MEMORY_LIMIT="${1#*=}"
        shift
        ;;
      *)
        shift
        ;;
    esac
  done
  
  local APP_DIR="${FORTRESS_APPS_DIR}/${APP_NAME}"
  [[ ! -d "${APP_DIR}" ]] && fatal "App '${APP_NAME}' not found"
  
  info "Setting resource limits for app: ${APP_NAME}"
  [[ -n "${CPU_LIMIT}" ]] && info "  CPU: ${CPU_LIMIT}"
  [[ -n "${MEMORY_LIMIT}" ]] && info "  Memory: ${MEMORY_LIMIT}"
  
  cd "${APP_DIR}"
  
  # Update docker-compose.yml with new limits
  if [[ -n "${CPU_LIMIT}" ]]; then
    sed -i "s/cpus: '.*'/cpus: '${CPU_LIMIT}'/" docker-compose.yml
  fi
  
  if [[ -n "${MEMORY_LIMIT}" ]]; then
    sed -i "s/memory: .*/memory: ${MEMORY_LIMIT}/" docker-compose.yml
  fi
  
  # Apply changes
  ${DOCKER_COMPOSE_COMMAND} up -d
  
  success "Resource limits updated!"
}